<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="autowiring" xmlns="http://docbook.org/ns/docbook"
	xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ns5="http://www.w3.org/1999/xhtml"
	xmlns:ns4="http://www.w3.org/1998/Math/MathML" xmlns:ns3="http://www.w3.org/2000/svg">
	<title>Autowiring</title>

	<sect1 xml:id="autowiring-instances">
		<title>Autowiring instances</title>
		<para>The Spring Actionscript container is able to autowire relationships between collaborating
			objects. This means that it is possible to automatically let Spring Actionscript resolve
			collaborators (other objects) for your object by inspecting the contents of the object
			definition. The autowiring functionality has five modes. Autowiring is specified per object
			and can thus be enabled for some objects, while other objects will not be autowired. Using
			autowiring, it is possible to reduce or eliminate the need to specify properties or
			constructor arguments, thus saving a significant amount of typing. When using
				<abbrev>XML</abbrev>-based configuration metadata, the autowire mode for a object definition
			is specified by using the autowire attribute of the <emphasis role="bold"
				>&lt;object/></emphasis> element. The following values are allowed:</para>        <table audience="" border="1" style="">
				<caption>Autowiring modes</caption>
				
				<thead>
					<tr>
						<th>Mode</th>
						
						<th>Explanation</th>
					</tr>
				</thead>
				
				<tr>
					<td>no</td>
					
					<td>No autowiring at all. Object references must be defined via a
						<literal>ref</literal> element. This is the default, and changing
						this is discouraged for larger deployments, since explicitly
						specifying collaborators gives greater control and clarity. To
						some extent, it is a form of documentation about the structure of
						a system.</td>
				</tr>
				
				<tr>
					<td>byName</td>
					
					<td>Autowiring by property name. This option will inspect the
						container and look for an object named exactly the same as the
						property which needs to be autowired. For example, if you have an
						object definition which is set to autowire by name, and it
						contains a <emphasis>master</emphasis> property, Spring
						Actionscript will look for an object definition named
						<literal>master</literal>, and use it to set the property.</td>
				</tr>
				
				<tr>
					<td>byType</td>
					
					<td>Allows a property to be autowired if there is exactly one
						object of the property type in the container. If there is more
						than one, a fatal exception is thrown, and this indicates that you
						may not use <emphasis>byType</emphasis> autowiring for that
						object. If there are no matching objects, nothing happens; the
						property is not set.</td>
				</tr>
				
				<tr>
					<td>constructor</td>
					
					<td>This is analogous to <emphasis>byType</emphasis>, but applies
						to constructor arguments. If there isn't exactly one object of the
						constructor argument type in the container, a fatal error is
						raised.</td>
				</tr>
				
				<tr>
					<td>autodetect</td>
					
					<td>Chooses constructor or <emphasis>byType</emphasis> through
						introspection of the object class. If a default (parameterless)
						constructor is found, the byType mode will be applied.</td>
				</tr>
			</table>
		<para>Note that explicit dependencies in <emphasis role="bold">&lt;property/></emphasis> and
				<emphasis role="bold">&lt;constructor-arg/></emphasis> settings always override autowiring.
			Please also note that it is not currently possible to autowire so-called simple properties
			such as primitives, Strings, and Classes (and arrays of such simple properties). (This is
			by-design and should be considered a feature.) When using either the <emphasis role="bold"
				>byType</emphasis> or constructor autowiring mode, it is possible to wire arrays. In such
			cases all autowire candidates within the container that match the expected type will be
			provided to satisfy the dependency.</para>
		<para> It is important to understand the various advantages and disadvantages of autowiring.
			Some advantages of autowiring include: <itemizedlist>
				<listitem>
					<para> Autowiring can significantly reduce the volume of configuration required. However,
						mechanisms such as the use of a object template (discussed elsewhere in this chapter)
						are also valuable in this regard. </para>
				</listitem>
			</itemizedlist><itemizedlist>
				<listitem>
					<para> Autowiring can cause configuration to keep itself up to date as your objects
						evolve. For example, if you need to add an additional dependency to a class, that
						dependency can be satisfied automatically without the need to modify configuration. Thus
						there may be a strong case for autowiring during development, without ruling out the
						option of switching to explicit wiring when the code base becomes more stable. </para>
				</listitem>
			</itemizedlist></para>
		<para> Some disadvantages of autowiring: <itemizedlist>
				<listitem>
					<para> Autowiring is more magical than explicit wiring. Although, as noted in the above
						table, Spring Actionscript is careful to avoid guessing in case of ambiguity which might
						have unexpected results, the relationships between your Spring Actionscript-managed
						objects are no longer documented explicitly. </para>
				</listitem>
				<listitem>
					<para> Wiring information may not be available to tools that may generate documentation
						from a Spring Actionscript container. </para>
				</listitem>
			</itemizedlist></para>
		<para>Another issue to consider when autowiring by type is that multiple object definitions
			within the container may match the type specified by the setter method or constructor argument
			to be autowired. For arrays, collections, or maps, this is not necessarily a problem. However
			for dependencies that expect a single value, this ambiguity will not be arbitrarily resolved.
			Instead, if no unique object definition is available, an Exception will be thrown. You do have
			several options when confronted with this scenario. First, you may abandon autowiring in favor
			of explicit wiring. Second, you may designate that certain object definitions are never to be
			considered as candidates by setting their 'autowire-candidate' attributes to 'false' as
			described in the next section. Third, you may designate a single object definition as the
			primary candidate by setting the '<emphasis role="bold">primary</emphasis>' attribute of its
				<emphasis role="bold">&lt;object/></emphasis> element to '<emphasis role="bold"
				>true'</emphasis>.</para>
		<para>When deciding whether to use autowiring, there is no wrong or right answer in all cases. A
			degree of consistency across a project is best though; for example, if autowiring is not used
			in general, it might be confusing to developers to use it just to wire one or two object
			definitions.</para>
		<para>This is an example of autowiring using <abbrev>XML</abbrev>
			configuration:<programlisting language="xml">&lt;object class="..." autowire="byType"/></programlisting></para>
		<para><abbrev>MXML</abbrev> configuration:</para>
		<programlisting language="xml">&lt;sas:Object clazz="{...}" autoWireMode="byType"/></programlisting>
		<para>Metadata configuration:</para>
		<programlisting language="actionscript">[Component(autowire="byType")]</programlisting>
		<note>
			<para> If a property is of type <literal>IApplicationContext</literal> or
					<literal>ApplicationDomain</literal> the application context instance or its
					<literal>ApplicationDomain</literal> property will be injected when autowiring <emphasis
					role="bold">byType</emphasis>.</para>
		</note>
		<sect2><title>Autowiring objects using annotations</title>
			<para> A different way of letting the Spring Actionscript container know how to configure an
				object is by adding specific metadata annotations to the component's sources. Obviously this
				is only possible when the developer actually has access to the source code. Thus, this
				solution does not apply to the situation in which you'd like to autowire existing objects,
				such as the ones that are already part of the Flex framework. </para>
			<para> The simplest way to inject a property by type is by decorating its source like this:
				<programlisting language="actionscript">public class ExampleComponent extends UIComponent {

	[Autowired]
	public var modelInstance:IModelLocator;

	public function ExampleComponent() {
		super();
	}

}</programlisting></para>
			<para>Once this component is created (or added to the stage), the Spring Actionscript
				container will search in its container an object of type <emphasis role="italic"
					>IModelLocator</emphasis> and assign it to the <emphasis role="bold"
					>modelInstance</emphasis> property of the <emphasis role="italic"
					>ExampleComponent</emphasis>.Wiring by name is also possible, all that is needed is a
				little extra metadata:</para>
			<programlisting language="actionscript">public class ExampleComponent extends UIComponent {

	[Autowired(mode='byName')]
	public var modelInstance:IModelLocator;

	public function ExampleComponent() {
		super();
	}

}</programlisting>
			<para>Now the Spring Actionscript container will look for an object in its configuration with
				the id '<emphasis role="bold">modelInstance</emphasis>' and assign this to the <emphasis
					role="bold">modelInstance</emphasis> property of the <emphasis role="italic"
					>ExampleComponent</emphasis>.There's another way of injecting by name, suited for the
				situation where the name of the property and the id in the configuration don't match. What
				if the <emphasis role="italic">IModelLocator</emphasis> instance described in the
				configuration has an id called '<emphasis role="bold">modelLocator</emphasis>' and for some
				reason this can't be easily changed?</para>
			<para>Easy, you can define the exact name in the metadata as follows:</para>
			<programlisting language="actionscript">public class ExampleComponent extends UIComponent {

	[Autowired(name='ModelLocator')]
	public var modelInstance:IModelLocator;

	public function ExampleComponent() {
		super();
	}

}</programlisting>
			<note>
				<para> When using the Autowired metadata do not forget to add these compiler settings to
					your Flex project: <emphasis role="bold">-keep-as3-metadata += Autowired</emphasis>.
				</para>
			</note></sect2>
		<sect2><title>Binding an object property to a property of an object in the container</title><para>To keep your objects as decoupled as possible it might be preferred not to inject the
				modelInstance into it, but just a certain property of the model. Since the data in the model
				is subject to change (usually it is populated with data retrieved from remote method
				invocations), it would also be good to bind your view to the model. </para>
			<para> This can be achieved by using the following metadata: </para>
			<programlisting language="actionscript">public class ExampleProductListComponent extends UIComponent {

	[Autowired(name='ModelLocator',property='products')]
	public var products:ArrayCollection;

	public function ExampleProductListComponent() {
		super();
	}

}</programlisting>
			<para> This example assumes that the ModelLocator object has a property called '<emphasis
					role="bold">products</emphasis>' of type <emphasis role="italic"
					>ArrayCollection</emphasis>. A binding is established between these two objects, so when
				the products <emphasis role="italic">ArrayCollection</emphasis> in the model in updated, so
				will the component. </para>
			<para> The property value can also be a chain of objects, so this will work as well: </para>
			<programlisting language="actionscript">public class ExampleProductListComponent extends UIComponent {

	[Autowired(name='ModelLocator',property='productManager.products')]
	public var products:ArrayCollection;

	public function ExampleProductListComponent() {
		super();
	}

}</programlisting>
			<note>
				<para>Since this functionality makes use of Flex binding it is therefore only available in
					Flex applications.</para>
			</note></sect2>
		<sect2><title>Injecting an object property with an external property value</title><para>Its also possible to inject the value of an external property into a autowired object. (If you
				want to know more about external properties read the section '<literal
					linkend="using-property-files">Using property files</literal>'). </para>
			<para> To do this add metadata to your source like this:</para>
			<programlisting language="actionscript">public class ExampleComponent extends UIComponent {

	[Autowired(externalProperty='currentURL')]
	public var websiteURL:String;

	public function ExampleComponent() {
		super();
	}

}</programlisting>
			<para> Where the value of the <emphasis role="bold">externalProperty</emphasis> metadata
				argument key matches the key in one of the loaded property files. </para></sect2>
	</sect1>
</chapter>
